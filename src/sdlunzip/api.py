""" A utility library for extracting log files from BMC generated log zip files."""
import os
import zipfile
from dataclasses import dataclass, field
from io import BytesIO
from typing import Final

from dotenv import load_dotenv

from .exceptions import (
    InvalidZipFile,
    LogFileNotFoundError,
    NoPasswordError,
    SdlunzipException,
)
from .status_codes import Status

load_dotenv()

LOGFILE_ENCODING: Final = "windows-1252"
REDFISH_FILENAME: Final = "redfish.txt"
SYSDEBUG_FILENAME: Final = "SystemDebugLog.html"
SYSDEBUG_ZIP_FILENAME: Final = "SystemDebugLog.zip"


# SDL_PASSWORD needed for log zip files with password protected system debug logs
try:
    SDL_PASSWORD = os.environb[b"SDL_PASSWORD"]  # zipfile expects binary string
except KeyError as e:
    raise NoPasswordError() from e


@dataclass
class Result:
    _exception: SdlunzipException | None = field(repr=False, default=None)
    text: str = ""
    zip: zipfile.ZipFile | None = None
    status_code: Status = field(init=False)

    def __post_init__(self):
        self.status_code = self._exception.STATUS_CODE if self._exception else Status.SUCCESS

    def __bool__(self) -> bool:
        return self.status_code == Status.SUCCESS

    def raise_for_status(self):
        if self._exception:
            raise self._exception


def get(zip_file: zipfile.ZipFile) -> Result:
    """Return contents of system debug log file or redfish log filefrom zip file.

    Regardless if zip file is bundled or not, password protected or not, this function attempts
    to find the actual system debug log file within it and returns the content of that log file
    as a string.

    Returns
        The string contents of the system debug log file within the zip file.

    """
    if not isinstance(zip_file, zipfile.ZipFile):
        return Result(InvalidZipFile())

    if _is_openbmc_zip(zip_file):
        return _result_from_zip(zip_file=zip_file, filename=REDFISH_FILENAME)

    if _is_bundled_zip(zip_file):  # sysdebug file one level down in bundled zip
        with zip_file.open(SYSDEBUG_ZIP_FILENAME) as sysdebug_zip_file:
            zip_file = zipfile.ZipFile(BytesIO(sysdebug_zip_file.read()))

    return _result_from_zip(zip_file, SYSDEBUG_FILENAME)


def _is_openbmc_zip(zip_file: zipfile.ZipFile) -> bool:
    """Test zip file to determine if it contains OpenBMC log files.

    Zipped log files generated by Intel server systems may contain IPMI based system debug
    logs, or for more recent systems, they may contain OpenBMC based system debug logs. This
    utility function allows the caller to test a zipped log file to see if it it contains an
    OpenBMC based system debug log.

    Returns
        True if the zip file matches the criteria associated OpenBMC based zipped log files,
        otherwise False.

    """
    try:
        # OpenBMC files have a root level system debug log file and a redfish message log file
        zip_file.getinfo(SYSDEBUG_FILENAME), zip_file.getinfo(REDFISH_FILENAME)  # type: ignore
    except KeyError:
        return False

    return True


def _is_bundled_zip(zip_file: zipfile.ZipFile) -> bool:
    """Test zip file to determine whether it is contains the actual zipped log file

    In some cases, rather than generating a zipped log file, an Intel server systems will
    generate a bundled zip file - a zip file containing the actual zipped log file. This occurs
    when there are two possible zipped log files, an encrypted one and a decrypted one.

    Returns
        True if the zip file has the actual zipped log file within it, otherwise False.

    """
    try:
        zip_file.getinfo(SYSDEBUG_ZIP_FILENAME)
    except KeyError:
        return False
    return True


def _result_from_zip(zip_file: zipfile.ZipFile, filename: str) -> Result:
    """Return text of filename from zip_file or empty string on error."""

    try:
        logtext = zip_file.read(filename, pwd=SDL_PASSWORD).decode(
            LOGFILE_ENCODING, errors="ignore"
        )  # no harm done by using password on an unprotected zip file.
    except KeyError:
        return Result(LogFileNotFoundError())
    else:
        logtext = logtext.replace("\r", "")  # remove windows CR artifacts
    finally:
        zip_file.close()

    return Result(_exception=None, text=logtext, zip=zip_file)
