"""Collection of code and functions for the decrypt API for SLA."""

import logging
import os
import zipfile
from io import BytesIO
from typing import Final

from dotenv import load_dotenv

load_dotenv()

logger = logging.getLogger(__name__)

PROTECTED_MASK: Final = 0x1
REDFISH_FILENAME: Final = "redfish.txt"
SYSDEBUG_ENCODING: Final = "windows-1252"
SYSDEBUG_FILENAME: Final = "SystemDebugLog.html"
SYSDEBUG_ZIP_FILENAME: Final = "SystemDebugLog.zip"


def is_openbmc_zip(zip_file: zipfile.ZipFile) -> bool:
    """Test zip file to determine if it contains OpenBMC log files.

    Zipped log files generated by Intel server systems may contain IPMI based system debug
    logs, or for more recent systems, they may contain OpenBMC based system debug logs. This
    utility function allows the caller to test a zipped log file to see if it it contains an
    OpenBMC based system debug log.

    Returns
        True if the zip file matches the criteria associated OpenBMC based zipped log files,
        otherwise False.

    """
    try:
        # OpenBMC files have a root level system debug log file and a redfish message log file
        zip_file.getinfo(SYSDEBUG_FILENAME), zip_file.getinfo(REDFISH_FILENAME)  # type: ignore
    except KeyError:
        return False

    return True


def is_protected_zip(zip_file: zipfile.ZipFile) -> bool:
    """Tests zip file to determine if system debug log file is password protected.

    Some IPMI based zipped log files contain password protected system debug log files. This
    utility function determines if that is the case for the specified zip file.

    Returns
        True if and only if the system debug log file within the zipped file is password
        protected, otherwsise, False.

    """
    try:
        zip_info = zip_file.getinfo(SYSDEBUG_FILENAME)
    except KeyError:
        return False  # treat an invalid file an unprotected

    return bool(zip_info.flag_bits & PROTECTED_MASK)


def is_bundled_zip(zip_file: zipfile.ZipFile) -> bool:
    """Test zip file to determine whether it is contains the actual zipped log file

    In some cases, rather than generating a zipped log file, an Intel server systems will
    generate a bundled zip file - a zip file containing the actual zipped log file. This occurs
    when there are two possible zipped log files, an encrypted one and a decrypted one.

    Returns
        True if the zip file has the actual zipped log file within it, otherwise False.

    """
    try:
        zip_file.getinfo(SYSDEBUG_ZIP_FILENAME)
    except KeyError:
        return False
    return True


def sysdebug_text_from_zip(zip_file: zipfile.ZipFile) -> str:
    """Return contents of system debug log file from zip file.

    Regardless if zip file is bundled or not, password protected or not, this function attempts
    to find the actual system debug log file within it and returns the content of that log file
    as a string.

    Returns
        The string contents of the system debug log file within the zip file.

    """
    pwd = os.environb[b"SDL_PASSWORD"]  # zip pwd expects byte encoding

    if is_bundled_zip(zip_file):  # sysdebug file one level down in bundled zip
        with zip_file.open(SYSDEBUG_ZIP_FILENAME) as sysdebug_zip_file:
            zip_file = zipfile.ZipFile(BytesIO(sysdebug_zip_file.read()))

    sysdebug_text = zip_file.read(SYSDEBUG_FILENAME, pwd=pwd).decode(
        SYSDEBUG_ENCODING, errors="ignore"
    )  # no harm done by using password on an unprotected zip file.

    return sysdebug_text.replace("\r", "")  # remove windows CR artifacts


def text_from_zip(zip_file: zipfile.ZipFile, filename: str) -> str:
    """Return text of filename from zip_file or empty string on error."""
    try:
        with zip_file.open(filename, "r") as file:
            # ZipFile contents are stored in binary format and need decoding
            raw_contents = file.read().decode(SYSDEBUG_ENCODING, errors="ignore")
            # Another Windows legacy - carriage returns that need to be stripped
            return raw_contents.replace("\r", "")
    except KeyError:
        return ""
